# 1、Redis的命令

`Set key value EX longTime` 设置过期时间

`ttl key`查询指定可以的过期时间，如果是负数，表明已经过期了。

<img src="/Users/jiang/Desktop/Workspace/笔记文档/Redis.assets/image-20230717151839607.png" alt="image-20230717151839607" style="zoom:50%;" />

当我们在执行Redis事务时，需要注意一点，它仅会阻止其他客户端对Redis服务器状态的改变，但会同时允许服务器从其他客户端接收相应的命令。

# 2、缓存和数据库一致性的问题

如何保证缓存和数据库一致性？

- 到底是更新缓存还是删缓存；
- 到底是先更新数据库，再删除缓存，还是先删除缓存，再更新数据库；
- 为什么要引入消息队列保证一致性；
- 延迟双删会有什么问题？

业务处于起步阶段，流量非常小，无论是读请求还是写请求，直接操作数据库即可，模型架构如下：

![image-20230718145004973](/Users/jiang/Desktop/Workspace/笔记文档/Redis.assets/image-20230718145004973.png)

随着业务量增长，项目的请求量越来越大，引入【缓存】来提高读性能。

![image-20230718144839064](/Users/jiang/Desktop/Workspace/笔记文档/Redis.assets/image-20230718144839064.png)

然后就面临一个问题，数据应该怎么存储？一种简单方案是：

- 数据库中的数据全量刷入缓存（不设置失效时间）；
- 写请求只更新数据库，不更新缓存；
- 启动一个定时任务、定时把数据库的数据，更新到缓存中。

![image-20230718145721765](/Users/jiang/Desktop/Workspace/笔记文档/Redis.assets/image-20230718145721765.png)

有两个问题：

1）缓存利用率低：不经常访问的数据，还一直留在缓存中；

2）数据不一致：因为是定时刷新缓存，缓存和数据库存在不一致；（数据的更改也会引起数据的不一致）

如何提高缓存利用率，很容易想到的方案是缓存中只保留最近访问的热数据，如何实现呢？

- 写请求依旧只写数据库；

- 读请求先读缓存，如果缓存不存在，则从数据库中读取，并重建缓存；

- 同时，写入缓存中的数据，都设置失效时间；

  这样一来，缓存中不经常访问的数据，随着时间的推移，都会过期，最终缓存中保留的，都是经常被访问的热数据，缓存利用率得以最大化。

![image-20230718150210145](/Users/jiang/Desktop/Workspace/笔记文档/Redis.assets/image-20230718150210145.png)

如何保证数据一致性？当数据更新时，不仅要更新数据库，需要连带缓存一起更新。数据库和缓存都更新，就会存在谁先谁后的问题。

**1.先更新缓存，后更新数据库；**

**2.先更新数据库，后更新缓存；**

正常情况下，无论谁先谁后，都可以让两者保持一致，但现在我们需要重点考虑异常情况，由于操作有两步，假设【第一步成功、第二步失败】。

**1.先更新缓存，后更新数据库**

如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，数据库中是旧值。虽然此时读请求可以命中缓存，拿到正确的值，但是一旦缓存失效，就会从数据库中读取到旧值，重建缓存也是这个旧值。这会对业务造成严重影响。

**2.先更新数据库，后更新缓存**

如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是旧值。之后的读请求读到的都是旧的数据，只有当缓存失效后，才能从数据中得到正确的值。这时，用户会发现，自己刚刚修改了数据，但是却看不到变更，一段时间过后，数据才变更过来，对业务也会造成影响。

可见，上述两种方案都存在弊端。这个问题应该如何解决？除了操作失败问题，还有什么场景会影响数据的一致性，那就是**并发问题**。

假设我们采用**【2.先更新数据库，再更新缓存】**的方案，思考一个并发场景，有线程A和线程B两个线程，需要更新同一条数据，会发生这样的场景：

1. 线程 A 更新数据库（X = 1）
2. 线程 B 更新数据库（X = 2）
3. 线程 B 更新缓存（X = 2）
4. 线程 A 更新缓存（X = 1）

最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。

> 同样，采用【1.先更新缓存，再更新数据库】也会出现类似问题。

这里通常的解决方案是，加**【分布式锁】**。

两个线程要修改「同一条」数据，每个线程在改之前，先去申请分布式锁，拿到锁的线程才允许更新数据库和缓存，拿不到锁的线程，返回失败，等待下次重试。这么做的目的，就是为了只允许一个线程去操作数据和缓存，避免并发问题。

前面我们提到使用【更新数据库+更新缓存】的方案会存在一些问题，那么使用【删除缓存】的方式能否解决呢？

**1.先删除缓存，后更新数据库；**

**2.先更新数据库，后删除缓存；**

同样，我们思考第二步操作失败的情况。【先删除缓存，后更新数据库，若第二步操作失败，则数据库没有更新成功，违背了本意但是数据库和缓存保持一致】。【先更新数据库，后删除缓存，若第二步操作失败，则数据库中的值是最新值，缓存中是旧值，数据不一致】。

**【备注：看了下文章，属实没看懂，主要是博客讲的逻辑不通顺】**

想要保证数据库和缓存一致性，**推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做**。

![image-20230718161609702](/Users/jiang/Desktop/Workspace/笔记文档/Redis.assets/image-20230718161609702.png)